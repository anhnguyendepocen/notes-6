## Tidying data
- Data rarely come to us as we want to use them.
- Before we can do analysis, typically have organizing to do.
- This is typical of ANOVA-type data, “wide format”: 

```
pig feed1 feed2 feed3 feed4
  1  60.8  68.7  92.6  87.9
  2  57.0  67.7  92.1  84.2
  3  65.0  74.0  90.2  83.1
  4  58.6  66.3  96.5  85.7
  5  61.7  69.8  99.1  90.3
```

- 20 pigs are randomly allocated to one of four feeds. At the end of the
study, the weight of each pig is recorded, and we want to know
whether there are any differences in mean weights among the feeds.
- Problem: want the weights all in one column, with 2nd column
labelling which feed each weight was from. Untidy!


## Tidy and untidy data (Wickham) 
- Data set easier to deal with if:
  - each observation is one row
  - each variable is one column
  - each type of observation unit is one table
- Data arranged this way called “tidy”; otherwise called “untidy”.
- For the pig data:
  - response variable is weight, but scattered over 4
columns, which are levels of a factor `feed`.
  - Want all the weights in one column, with a second column `feed`
saying which feed that weight goes with.
  - Then we can run `aov`.
  
## Reading in the pig data

```{r, message=F}
my_url="http://www.utsc.utoronto.ca/~butler/c32/pigs1.txt"
pigs1=read_delim(my_url," ")
pigs1
```

## Gathering up the columns
- This is a very common reorganization, and the magic “verb” is
`gather`:
```{r}
pigs1 %>% gather(feed,weight,feed1:feed4) -> pigs2
```

- `pigs2` is now in “long” format, ready for analysis. See next page.
- Anatomy of `gather`: what makes the columns different (different
feeds), what makes them the same (all weights), which columns to
combine.

## Long format pigs

```{r}
pigs2
```

## ...and finally, the analysis
- which is just what we saw before:
```{r}
weight.1=aov(weight~feed,data=pigs2)
summary(weight.1)
```

- The mean weights of pigs on the different feeds are definitely not all
equal.
- So we run Tukey to see which ones differ (over).

## Tukey

```{r}
TukeyHSD(weight.1)
```

All of the feeds differ! 

## Mean weights by feed 

To find the best and worst, get mean weight by 
feed group. I borrowed an idea from later to put the means in descending order:

```{r}
pigs2 %>% group_by(feed) %>%
  summarize(mean_weight = mean(weight)) %>%
  arrange(desc(mean_weight))
```

Feed 3 is best, feed 1 worst.

## Should we have any concerns about the ANOVA?  xxx chat under

```{r, fig.height=3}
ggplot(pigs2,aes(x=feed,y=weight))+geom_boxplot()
```

Feed 2 has an outlier, but there are only 5 pigs in each group, and the
conclusion is so clear that I am OK with this.

## Tuberculosis

- The World Health Organization keeps track of number of cases of
various diseases, eg. tuberculosis.
- Some data:

```{r}
my_url="http://www.utsc.utoronto.ca/~butler/c32/tb.csv"
tb=read_csv(my_url)
```

- Variables (see over): country (abbreviated), year. Then number of
cases for each gender and age group, eg. `m1524` is males aged 15–24.
Also `mu` and `fu`, where age is unknown.
- Lots of missings. Want to get rid of.

## The data

```{r}
glimpse(tb)
```

## Gather the gender-age group columns

```{r}
tb %>% gather(genage, freq, m04:fu, na.rm = T) -> tb2
```

- what makes the columns-to-be-gathered different, then
- what makes them the same, then
- the columns to gather, then (optionally)
- get rid of the missing values.

## Results (some)

```{r}
tb2
```

## Separating
- 4 columns, but 5 variables, since `genage` xxx contains both gender and
age group. Split that up using separate.
- `separate` needs 3 things:
  - what to separate (no quotes needed),
  - what to separate into (here you do need quotes),
  - how to split.
- For “how to split”, here “after first character”:
```{r}
tb2 %>% separate(genage, c("gender", "age"), 1) -> tb3
```

## Tidied tuberculosis data (some)

```{r}
tb3
```

## In practice...

- instead of doing the pipe one step at a time, you *debug* xxx it one step at
a time, and when you have each step working, you use that step’s
output as input to the next step, thus:
```{r}
tb %>% gather(genage, freq, m04:fu, na.rm = T) %>%
  separate(genage, c("gender", "age"), 1) -> tb3
```

- You can split the R code over as many lines as you like, as long as
each line is incomplete, so that R knows more is to come.
- I like to put the pipe symbol on the end of the line.

## Total tuberculosis cases by year (some of the years)

```{r}
tb3 %>% group_by(year) %>%
  summarize(cases = sum(freq)) %>%
  filter(between(year, 1990, 1999))
```

xxx

- Something very interesting happened between 1994 and 1995.

## Some weather data

```{r}
my_url="http://www.utsc.utoronto.ca/~butler/c32/weather.csv"
weather=read_csv(my_url)
```

## The data (some)

```{r}
weather
```

## The columns

- Daily weather records for a weather station in Mexico:

  - *id*: identifier for this weather station (always same here)
  - *year*, *month*: obvious 
  - *element*: whether temperature given was daily max or daily min
  - *d1, d2*,...: day of the month from 1st to 31st.

- Numbers in data frame all temperatures (for different days of the month),
so first step is

```{r}
weather %>% gather(day, temperature, d1:d31, na.rm = T) -> d
```

## So far

```{r}
d
```

## The days
- Column `element` xxx contains names of two different variables, that
should each be in separate column.
- Distinct from eg. `m1524` xxx in tuberculosis data, that contained levels of
two different factors, handled by separate.
- Untangling names of variables handled by `spread`:

```{r}
weather %>%
gather(day,temperature,d1:d31,na.rm=T) %>%
spread(element,temperature) -> d
```

## So far

```{r}
d
```

## Further improvements
- We have tidy data now, but can improve things further.
- `mutate` creates new columns from old (or assign back to change a
variable).
- Would like the numerical dates. `separate` works, but also produces
column named `d` whose value is always `d`. Instead pull out number as
below.
- `select` keeps columns (or drops, with minus). Station `id` has no
value to us:

```{r}
weather %>%
  gather(day, temperature, d1:d31, na.rm = T) %>%
  spread(element, temperature) %>%
  mutate(day = parse_number(day)) %>%
  select(-id) -> d
```

## So far

```{r}
d
```

## Final step(s)
- Make year-month-day into proper date.
- Keep only date, tmax, tmin:
```{r}
weather %>%
  gather(day, temperature, d1:d31, na.rm = T) %>%
  spread(element, temperature) %>%
  mutate(day = parse_number(day)) %>%
  select(-id) %>%
  unite(datestr, c(year, month, day), sep = "-") %>%
  mutate(date = as.Date(datestr)) %>%
  select(c(date, tmax, tmin)) -> weather_tidy
```

## Our tidy data frame

```{r}
weather_tidy
```

## Plotting the temperatures
- Plot temperature against date joined by lines, but with separate lines
for max and min.
- ggplot requires something like
```{r, eval=F}
ggplot(...,aes(x=date,y=temperature))
```

only we have two temperatures, one a max and one a min, that we
want to keep separate.

- xxx The trick: combine `tmax` and `tmin` together into one column, keeping
track of what kind of temp they are. (This actually same format as
untidy `weather`) Are making `weather_tidy`
untidy for purposes of drawing graph only.
- Then can do something like
```{r, eval=F}
ggplot(...,aes(x=date,y=temperature,colour=maxmin)
```

to distinguish max and min on graph.

## Setting up plot
- Since we only need data frame for plot, we can do the
column-creation and plot in a pipeline.
- The temperature columns are actually text (see printout of
`weather_tidy`), but for graph they need to be numbers.
- For a `ggplot` in a pipeline, the initial data frame is omitted, because it
is whatever came out of the previous step.
- To make those “one column”s: `gather`. I save the graph to show overleaf:
```{r}
weather_tidy %>%
gather(maxmin,temperature,tmax:tmin) %>%
mutate(temperature=as.numeric(temperature)) %>%
ggplot(aes(x=date,y=temperature,colour=maxmin))+
geom_line() -> g
```

## The plot xxx

```{r, fig.height=4}
g
```

## Summary of tidying “verbs”

  \begin{tabular}{lp{0.7\textwidth}}
    Verb & Purpose\\
    \hline
    \texttt{gather}& Combine columns that measure same thing into one\\
    \texttt{spread}& Take column that measures one thing under
                     different conditions and put into multiple columns\\
    \texttt{separate} & Turn a column that encodes
                        several variables into
                        several columns\\
    \texttt{unite} & Combine several (related) variables into one
                     ``combination'' variable\\
    \hline
  \end{tabular}
  
  \texttt{gather} and \texttt{spread} are opposites; \texttt{separate}
  and \texttt{unite} are opposites.

xxx end for now

